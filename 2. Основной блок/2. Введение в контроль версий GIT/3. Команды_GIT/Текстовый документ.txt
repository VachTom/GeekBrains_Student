git remote add origin https://github.com/VachTom/Repo.git
git branch -M main
git push -u origin main




# __*Инструкция по командам Git*__

## __*I. Настройка*__
git config --global user.name ‘Username’
git config --global user.email ‘username@somemail.com’

1. __*git init*__
*     Создает репозиторий (создает скрытую папку внутри папки)

## __*II. Основные команды*__

2. __*git add .\ИМЯ_ФАЙЛА.md*__
*     Контроль версий отслеживаeтся. Красный не отслеживаемый, Зеленый отслеживаемый). Если красный нужно применить команду добавления __*git add .\ИМЯ_ФАЙЛА.md*__ и тогда статус файла будет зеленым, тогда контроль версий будет отслеживаться.


3. __*git add .*__
*     Отслеживание ВСЕХ файлов (к примеру у нас 100 файлов и чтобы не перемещаться по каждому файлу и ставить git add можно использовать эту команду)

4. __*git status*__
*     Посмотреть текущую ветку, незакоммиченные файлы и другую информацию:



## __*III. Комиты*__

1. __*git commit -m ""НАЗВАНИЕ СОХРАНЕНИЯ""*__
*     Комиты - сохранения

2. __*git commit -a*__

*     Дает возможность расписать большое примечание/комментарий на пару абзацев. Это отличие от обычного сохранения через -m. Также отличие в том что, эта команда автоматом отслеживает файл (т.е. не нужно перед комитом писать __*git add*__)

- - Шаг № 1. После нужно нажать SHIFT+ I (i)
- - Шаг № 2. Дальше прописать название комита/примечание/ комментарий. 
- - Шаг № 3. Дальше нажать ESC. 
- - Шаг № 4. Дальше нажать SHIFT+ : . 
- - Шаг № 5. Дальше внизу появляется возможность ввода. Нажимаете wq (если хотите что-то изменить), либо просто q (Если подверждаете изменения) + ENTER .(РАСКЛАДКА ДОЛЖНА БЫТЬ АНГ.). 


3. __*git reset --hard HEAD~*__
*     Полное удаление последнего комита 

4. __*git reset HEAD~"НАЗВАНИЕ СОХРАНЕНИЯ"*__ 
*     Отменить последний коммит"




## __*IV. Хроногия комитов __*git log*__*__
1. git log 
*     Просмотр всех комитов (сохранений) 

2. git log --oneline
*     укороченный вариант прсмотра 

3. git log --graph
*     Грфическое отображение "Дерева" всех комитов

4. git dif
*     сравнение (различие) относительно последнего комита?




## __*V. Ветки*__
1. git branch 
*     Выводит список веток которые у нас есть (знак * означает что мы находимся на этой ветке)

2. git branch ИМЯ_ВЕТКИ
*     Создает новую ветку

3. git branch -d ИМЯ_ВЕТКИ 
*     Удаляет выбранную ветку
4. git branch -M ИМЯ ВЕТКИ 
*     Указывает основную ветку

## __*VI. Работа с комитами и ветками*__
1. git checkout ИМЯ_СОХРАНЕНИЯ (УНИКАЛЬНЫЙ КОД СОХРАНЕНИЯ)
*     Переход между комитами
2. git checkout ИМЯ_ВЕТКИ
*     Переход между ветками


3. git merge
*     Слияние ветки с другой. ОЧЕНЬ ВАЖНО! Сливается с того места откуда пишете код (Т.е. если вы хотите чтобы изменнения были в мастере, вам сперва нужно перейти в ветку масте через чэкАут, только потом писать команду слива)


## __*VII. Для удаленного репозитория*__

1. git push
*     Передает всю инф в удаленный gutHub из прог gut

2. git pull

*     "Стягивает" с удаленного репозитория gutHub всю инф в локальный репозиторий. Нужно понимать что эта команда также сливает (merge)!

3. git clone ССЫЛКА
*     Клонирует содержимое из удаленного репозитория в локальный 

4. Fork
*     Копирует содержимое из удаленного репозитория в удаленный репозиторий gutHub

5. git cb



## __*VIII. Дополнительно. (Пока не применял) Инф. взял с интернета*__

Stash
1. Используйте команду __*git stash*__, чтобы сохранить рабочую область и индекс без применения коммита и вернуться к чистой рабочей директории. Это может пригодиться, если работа еще не закончена и рано вносить изменения на проект.

2. Просмотреть стек спрятанных данных можно с помощью команды __*git stash list*__. Дополнительные данные покажет команда __*git stash show*__.

3. Строка вида stash@{0}, отображаемая при выполнении команды __*git stash list*__ - это номер сохраненных изменений в стеке, по которому можно эти данные восстановить или удалить.

4. Для восстановления данных есть команда __*git stash apply*__, если запустить её без параметров, будет восстановлена рабочая область последнего в стеке сохранения. Чтобы восстановить конкретный номер в стеке укажите его: __*git stash apply stash@{0}*__ или с помощью сокращенного варианта __*git stash apply*__ 0.

5. Команда __*git stash pop*__ применяет спрятанные изменения и удаляет их из стека.

6. Команда __*git stash drop [stash-name]*__ удаляет указанную заначку, или последнюю, если номер явно не указан.